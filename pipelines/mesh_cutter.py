from vedo import Mesh, write, merge, Sphere, Lines, Points, Plane
from vedo.pointcloud import recoSurface
from vedo.pointcloud import fitCircle
import os
import numpy as np
import vtk
from vedo.plotter import show
from math import sqrt


class MeshCutter(object):
    def __init__(self, config):
        self.config = config

        self.colors = [
            '0 0 0 1 0',
            '128 128 128 1 1',
            '0 255 0 1 2',
            '0 0 255 1 3',
            '255 255 0 1 4',
            '0 255 255 1 5',
            '255 0 255 1 6',
            '192 192 192 1 7',
            '255 0 0 1 8',
            '128 0 0 1 9',
            '128 128 0 1 10',
            '0 128 0 1 11',
            '128 0 128 1 12',
            '0 128 128 1 13',
            '0 0 128 1 14',
            '210 105 30 1 15',
            '255 20 147 1 16',
            '75 0 130 1 17',
            '47 79 79 1 18',
            '46 139 87 1 19',
            '240 230 140 1 20',
            '255 165 0 1 21',
            '250 128 114 1 22',
            '165 42 42 1 23',
            '102 205 170 1 24',
            '135 206 235 1 25',
            '138 43 226 1 26',
            '218 112 214 1 27',
            '160 82 45 1 28',
            '176 196 222 1 29',
            '245 245 220 1 30',
            '0 100 0 1 31',
            '0 0 100 1 32'
        ]

        self.min_pos_label, self.max_pos_label = 1, 16
        if config.arch == 'lower':
            self.min_pos_label, self.max_pos_label = 17, 32

    def cut_and_export(self, mesh, labels, order_to_predict, intersection_lines=None, method='stl', colored=False, write_to_path=None, cut_gum_mesh=False):
        """
            Method for cutting a segmented mesh based on its labels
            params:
                - mesh: the mesh to cut
                - labels: labels returned by prediction tool
                - order_to_predict: name of the order for keeping track of good and bad segmentations
                - intersection_lines: separation lines (None if we don't want to export it)
                - method: method for the exported file. Currently supported: 'stl', 'ply' (and the rest of formats supported by Vedo)
                - colored: wether to export the segmentation as a single ply. It only has effect if method is stablished as 'ply'
        """
        points = mesh.points().copy()
        faces = np.asarray(mesh.faces())

        dest_path = f'{self.config.export_stls_path}/{order_to_predict}/segmentation' if int(
            order_to_predict) > 0 else write_to_path

        if dest_path is None:
            raise Exception('Destination path is not defined')

        if not os.path.exists(dest_path):
            os.makedirs(dest_path)

        # ------- No need for intersection lines for now -------------#
        if intersection_lines is not None:
            ext = method if write_to_path is None else 'ply'
            write(intersection_lines,
                  f'{dest_path}/{self.config.arch}_intersection_lines.ply', binary=False)

        if method == 'ply' and colored is True:
            ofile = open(f'{dest_path}/processed.ply', 'w')
            ofile.write(f"""ply
format ascii 1.0
comment VTK generated PLY File
comment PLY file generated by vedo
obj_info vtkPolyData points and polygons: vtk4.0
element vertex {points.shape[0]}
property float x
property float y
property float z
property uchar red
property uchar green
property uchar blue
property uchar alpha
property int tooth_id
element face {faces.shape[0]}
property list uchar int vertex_indices
end_header\n""")
            # element face {faces.shape[0]}
            # property list uchar int vertex_indices
            inserted = [False for point in points]
            pts = ""
            lbls = ""
            # for point in points:
            #    ofile.write(f"{point[0]:0.6f} {point[1]:0.6f} {point[2]:0.6f}\n")

            #positive_idxs = np.where(labels > 0)
            #zero_idxs = np.where(labels == 0)

            for label, face in zip(labels, faces):
                lbls += f"3 {face[0]} {face[1]} {face[2]}\n"
                if not inserted[face[0]]:
                    pts += f"{points[face[0]][0]:0.6f} {points[face[0]][1]:0.6f} {points[face[0]][2]:0.6f} {self.colors[label]}\n"
                    inserted[face[0]] = True
                if not inserted[face[1]]:
                    pts += f"{points[face[1]][0]:0.6f} {points[face[1]][1]:0.6f} {points[face[1]][2]:0.6f} {self.colors[label]}\n"
                    inserted[face[1]] = True
                if not inserted[face[2]]:
                    pts += f"{points[face[2]][0]:0.6f} {points[face[2]][1]:0.6f} {points[face[2]][2]:0.6f} {self.colors[label]}\n"
                    inserted[face[2]] = True

            ofile.write(pts)
            ofile.write(lbls)

            ofile.close()
            return

        # Attempt to add a cap to the initial mesh. It seems that cap does not work as
        # expected in non-convex polygons.
        # Also, as the cap function does not return a plane (it's not really a plane), it's a
        # bit complicated the use of borders to 'fix' the cap's return
        mult = 1 if self.config.arch == 'lower' else -1
        gum_mesh, int_point = self.apply_lines_cut(
            mesh, intersection_lines, True)

        gum_cap = self.find_gum_cap(gum_mesh, int_point)
        gum_mesh = merge(gum_mesh, gum_cap)
        pln = Plane((points[0][0], points[0][1] + 10 *
                    mult, points[0][1]), (0, mult, 0))
        gum_mesh = gum_mesh.cutWithMesh(pln)

        quarter_1 = gum_mesh.clone().crop(left=0, right=0.5)
        quarter_2 = gum_mesh.clone().crop(left=0.5, right=0)
        cap_1 = quarter_1.cap(
            returnCap=True).extractLargestRegion().crop(left=0, right=0.5).extractLargestRegion()
        cap_2 = quarter_2.cap(
            returnCap=True).extractLargestRegion().crop(left=0.5, right=0).extractLargestRegion()

        gum_mesh = merge(gum_mesh, cap_1, cap_2)
        pln = Plane((points[0][0], points[0][1] + 10 *
                    mult, points[0][1]), (0, mult, 0))
        gum_mesh = gum_mesh.cutWithMesh(pln)

        cap_3 = gum_mesh.cap(returnCap=True).extractLargestRegion()

        gum_cap = gum_cap.subdivide(N=1, method=2, mel=0.7).decimate(
            fraction=0.5, N=len(points)/2, method='pro', boundaries=True)
        #write(gum_cap, 'gum_cap_2.stl')
        # return

        for label in range(0, 33):
            if label == 0:
                name = self.config.arch+'_Jaw'
            else:
                name = str(label)

            idxs = np.where(labels == label)
            #print('label:', label, 'len:', len(idxs[0]))

            if not len(idxs[0]):
                continue

            __faces = faces[idxs[0]]
            _mesh = Mesh([points, __faces])  # .extractLargestRegion()

            # --------- No need models without cap -------------#
            #write(_mesh, f'{dest_path}/{name}.{method}', binary=False)

            #gum_mesh = gum_mesh.boolean('-', _mesh)
            if label == 0:
                _mesh, _ = self.apply_lines_cut(_mesh, intersection_lines)

                _mesh = merge(_mesh, cap_1, cap_2, cap_3, gum_cap)
                pln = Plane((points[0][0], points[0][1] +
                            10*mult, points[0][1]), (0, mult, 0))
                _mesh = _mesh.cutWithMesh(pln)

                _mesh = _mesh.extractLargestRegion()

                write(_mesh, f'{dest_path}/{name}_cap.{method}', binary=False)
                # return
                continue
                # break

            _mesh = _mesh.extractLargestRegion()
            _mesh2 = self.add_teeth_cap(_mesh)
            #write(_mesh2, f'{dest_path}/{name}_cap.{method}', binary=False)

        #name = self.config.arch+'_Jaw'
        #write(gum_mesh, f'{dest_path}/{name}.{method}', binary=False)

    def add_teeth_cap(self, _mesh):
        mult = -1 if self.config.arch == 'lower' else 1
        cap_size = 10 * mult
        cm = _mesh.centerOfMass()
        pt = [cm[0], cm[1] + cap_size, cm[2]]

        cap_faces = []

        b = _mesh.boundaries().extractLargestRegion()  # .clone()
        bpoints = b.points().copy().tolist()

        y_array = [p[1] for p in bpoints]
        _min_max = min(
            y_array) if self.config.arch == 'lower' else max(y_array)

        _cap_points = [[p[0], _min_max, p[2]] for p in bpoints]

        lp = len(bpoints)
        # print(b_p)

        for idx1, idx2 in b.lines():
            cap_faces.append([idx1, idx2, idx1+lp])
            cap_faces.append([idx2, idx1+lp, idx2+lp])

            cap_faces.append([idx1+lp, idx2+lp, lp + len(y_array)])

        '''
        back, front = 0.5, 0
        if self.config.arch == 'lower':
            back, front = front, back

        
        _tmp = fitCircle(_cap_points)
        
        _radius = _tmp[1]
        pt = _tmp[0]

        min_dist = 1e5  # Ensures a big inital distance
        for _pt in _cap_points:
            _dt = sqrt((pt[0] - _pt[0])**2 + (pt[2] - _pt[2])**2)
            if _dt < min_dist:
                min_dist = _dt

        _radius = min(min_dist, _radius)
        sp = Sphere(pos=pt).scale(
            [_radius*1.5, 10, _radius*1.5]).crop(back=back, front=front)
        pt = [pt[0], pt[1]+5.9*mult, pt[2]]
        '''
        pt = [pt[0], pt[1]+15*mult, pt[2]]

        pln = Plane((pt[0], pt[1]-17*mult, pt[2]), normal=(0, mult, 0))

        tmp_mesh = Mesh([bpoints + _cap_points + [pt], cap_faces])

        tmp_mesh = merge(_mesh, tmp_mesh)

        tmp_mesh_2 = tmp_mesh.cutWithMesh(pln)
        tmp_cap = tmp_mesh_2.cap(returnCap=True)

        #tmp_mesh = merge(tmp_mesh, sp)

        tmp_mesh = merge(tmp_mesh_2, tmp_cap)
        #tmp_mesh = tmp_mesh.cap()

        #tmp_mesh = tmp_mesh.boolean('+', sp)

        return tmp_mesh  # tmp_mesh

    def add_teeth_cap_old(self, _mesh):
        mult = -1 if self.config.arch == 'lower' else 1
        cap_size = 10 * mult

        cm = _mesh.centerOfMass()
        pt = [cm[0], cm[1] + cap_size, cm[2]]
        cap_faces = []

        b = _mesh.boundaries().clone()

        #b_p = build_point_loop(b.points().copy(), b.lines())
        b_p = _mesh.boundaries(returnPointIds=True)
        # print(_boundaries_idx_loop)
        # input()

        #_points = points.tolist() + [pt]
        _points = _mesh.points().copy().tolist()  # + [pt]

        y_array = [p[1] for p in b.points()]
        _min_max = min(
            y_array) if self.config.arch == 'lower' else max(y_array)
        _cap_points = [[p[0], _min_max, p[2]] for p in b.points()]
        lp = len(_points)
        for idx1, idx2 in b.lines():
            cap_faces.append([b_p[idx1], b_p[idx2], idx1+lp])
            cap_faces.append([b_p[idx2], idx1+lp, idx2+lp])

            cap_faces.append([idx1+lp, idx2+lp, lp + len(y_array)])

        back, front = 0.5, 0
        if self.config.arch == 'lower':
            back, front = front, back

        #_radius = make_circle([[p[0], p[2]] for p in _cap_points])[2]-1.5
        _tmp = fitCircle(_cap_points)
        _radius = _tmp[1]
        pt = _tmp[0]

        min_dist = 1e5  # Ensures a big inital distance
        for _pt in _cap_points:
            _dt = sqrt((pt[0] - _pt[0])**2 + (pt[2] - _pt[2])**2)
            if _dt < min_dist:
                min_dist = _dt

        _radius = min(min_dist, _radius)
        # sp = Sphere(pos=pt).scale(
        #    [_radius*1.5, 10, _radius*1.5]).crop(back=back, front=front)
        #pt = [pt[0], pt[1]+5.9*mult, pt[2]]

        pt = [pt[0], pt[1]+15*mult, pt[2]]

        pln = Plane((pt[0], pt[1]-9*mult, pt[2]), normal=(0, mult, 0))

        tmp_mesh = Mesh([_points + _cap_points + [pt],
                        _mesh.faces().copy() + cap_faces])

        tmp_mesh_2 = tmp_mesh.cutWithMesh(pln)
        tmp_cap = tmp_mesh_2.cap(returnCap=True)

        #tmp_mesh = merge(tmp_mesh, sp)

        tmp_mesh = merge(tmp_mesh_2, tmp_cap)
        #tmp_mesh = tmp_mesh.cap()

        #tmp_mesh = tmp_mesh.boolean('+', sp)

        return tmp_mesh  # tmp_mesh

    def apply_lines_cut(self, mesh, intersection_lines, largest_region=False):
        _lines = intersection_lines.clone()

        cut_distance = 1.5
        mesh_points = mesh.points().copy()
        mesh_points = [i[1] for i in mesh_points]
        max_mesh_point, min_mesh_point = max(mesh_points), min(mesh_points)
        line_points = _lines.points().copy()
        line_points = [i[1] for i in line_points]
        int_point = min(
            line_points)-cut_distance if self.config.arch == 'lower' else max(line_points)+cut_distance

        if self.config.arch == 'lower':
            back_proportion = (int_point - min_mesh_point) * \
                1. / (max_mesh_point - min_mesh_point)
            front_proportion = 0.
        else:
            back_proportion = 0.
            front_proportion = (max_mesh_point - int_point) * \
                1. / (max_mesh_point - min_mesh_point)

        _msh = mesh.clone().crop(back=back_proportion,
                                 front=front_proportion)  # .extractLargestRegion()
        if largest_region:
            _msh = _msh.extractLargestRegion()

        return _msh, int_point

    def find_gum_cap(self, _msh, int_point):
        extrude_size = 3
        if self.config.arch == 'lower':
            extrude_size *= -1

        _msh_boundaries = _msh.boundaries().extractLargestRegion()

        _msh2 = _msh_boundaries.clone()
        _msh2_points = _msh2.points().copy().tolist()
        _msh2 = Mesh(_msh2)

        _msh3_points = [[p[0], int_point+extrude_size, p[2]]
                        for p in _msh2_points]

        mult = -1 if self.config.arch == 'lower' else 1
        pln = Plane(_msh3_points[0], (0, mult, 0))

        all_points = _msh3_points + _msh2_points
        all_faces = []
        _msh3_lines = _msh2.lines()
        _msh3_size = len(_msh3_points)
        for idx1, idx2 in _msh3_lines:
            all_faces.append([idx1, idx2, idx1+_msh3_size])
            all_faces.append([idx2, idx2+_msh3_size, idx1+_msh3_size])

        _msh4 = Mesh([all_points, all_faces])
        # Return the basis

        return _msh4
